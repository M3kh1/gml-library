
// When creating goap actions think:
/*

	GOAP gets you to the party.
	The party handles itself.
	
	GOAP is about getting into the right context.

	The agent doesn’t plan every bite of food with GOAP —
	It just planned to get to the fridge.
	
*/

// Started : 4:00 PM on April 25, 2025.
// Ended 9:00 PM on April 25, 2025



function brainGOAP() constructor
{
	randomize();
	
	actions = {};
	goals = {};
	sensors = {};
	
	targetGoal = undefined;
	
	Log = new Logger("GOAP/Brain", true, [LogLevel.debug, LogLevel.info, LogLevel.warning]);
	
	planner = new plannerGOAP(); 
	plan = [];
	currentActionIndex = 0;  // init action index
	
	
	
	#region Primary User Functions
	
	addAction = function(_action)
	{
		
		var _name = _action.name;
		
		if struct_exists(actions, _name)
		{
			Log.logWarning($"Action ({_name}) Exists Already.");
			return;
		}
		
		struct_set(actions, _name, _action);
		
	}
	
	addActionsByArray = function(_actions)
	{
		for(var i=0; i<array_length(_actions); i++)
		{
			var _a = _actions[i];
			addAction(_a);
		}
	}
	
	addGoal = function(_goal)
	{
		
		var _name = _goal.name;
		
		if struct_exists(goals, _name)
		{
			Log.logWarning($"Goal ({_name}) Exists Already.");
			return;
		}
		
		struct_set(goals, _name, _goal);
		
	}
	
	addGoalsByArray = function(_goals)
	{
		for(var i=0; i<array_length(_goals); i++)
		{
			var _g = _goals[i];
			addGoal(_g);
		}
	}
	
	
	registerSensor = function(_name, _func)
	{
		
		if struct_exists(sensors, _name)
		{
			Log.logWarning($"Sensor ({_name}) Exists Already.");
			return;
		}
		
		struct_set(sensors, _name, _func);
		
	}
	
	
	getSensorData = function(_name)
	{
		var _sensor = struct_get(sensors, _name);
		
		if _sensor == undefined
		{
			Log.logWarning($"Sensor: {_name} DNE.");
			return false;
		}
		
		return _sensor();
		
	}
	
	
	setTargetGoal = function(_goalName)
	{
		
		//show_debug_message("Goals: "+string(goals));
		
		if !struct_exists(goals, _goalName)
		{
			Log.logWarning("Set target goal failed. Goal DNE.");
			return;
		}
		
		targetGoal = struct_get(goals, _goalName);
		
	}
	
	initPlan = function(_plan=[])
	{
		plan = _plan;
		currentActionIndex = 0;
	}
	
	generatePlan = function()
	{
	    var _startTime = current_time;
    
	    var current_state = captureSensorSnapshot();
	    var goal_state = targetGoal.conditions;
	    var available_actions = actions;

	    var new_plan = planner.createPlan(current_state, goal_state, available_actions);
	    var plan_valid = (array_length(new_plan) > 0);

	    if (!plan_valid)
	    {
			Log.logDebug("No valid plan could be generated.");
			
	        return false;
	    }

	    initPlan(new_plan); // Update plan with the new one

	    var _endTime = (current_time - _startTime);
		
		
		Log.logDebug($"New plan generated in ({string_format(_endTime, 0, 2)} ms) successfully.");
		
		printPlan();
		
	    return true;
	}



	#endregion

	#region ALL Helper Functions
	
	#region -- Base Helper Functions
	
	captureSensorSnapshot = function()
	{
		var _snap = {};
		
		var _sensor_names = struct_get_names(sensors);
		
		for(var i=0; i<array_length(_sensor_names); i++)
		{
			var _name = _sensor_names[i];
			
			var _val = struct_get(sensors, _name);
			
			var _funct_ran = _val();
			
			struct_set(_snap, _name, _funct_ran);
		}
		
		return _snap;
		
	}

	printPlan = function()
	{
		var _len = array_length(plan);
		
		if (_len <= 0)
		{
			show_debug_message("Print Plan - Plan is empty.");
			return;
		}
		
		show_debug_message($"({_len}) ~ Printing Plan:");
		
		//show_debug_message(string(plan));
		
		for(var a=0; a<_len; a++)
		{
			
			var _act = plan[a];
			show_debug_message($"{a+1}: {_act}");
			
		}
		
	}
	
	drawSensors = function(_x, _y)
	{
		var _sensor_names = struct_get_names(sensors);
		
		for(var i=0; i<array_length(_sensor_names); i++)
		{
			var _sensor = _sensor_names[i];
			var _val = struct_get(sensors, _sensor);
			
			draw_text(_x, (_y-(20*i)), $"Sensor: {_sensor} ~ {_val()}");
			
		}
		
	}
	
	#endregion
	
	#region --- FSM Helper Functions ---
	
	shouldInterruptAction = function(_act)
	{
		var _result = !planner.checkKeysMatch(_act.conditions, captureSensorSnapshot()) && _act.isInterruptible;	
		return _result;
	}

	handleActionInterruption = function(_act)
	{
	    
		Log.logWarning($"Regenerating Plan: Preconditions no longer valid (Interrupting) {plan[currentActionIndex]}");
		
	    // Standard GOAP interruption sequence
	    _act.cleanup();  
    
	    generatePlan();   // Generate new plan
	    fsm.setState("start");  // Transition out of executing
	}

	isActionComplete = function(_act)
	{
		
		var _goapReactionsMet = planner.checkKeysMatch(_act.reactions, captureSensorSnapshot());
		
		if (!_goapReactionsMet)
		{
	        //Log.logWarning($"Action '{_act.name}' not completed. Reactions not met.");
	    }
		
		return _goapReactionsMet; // Action is complete if reactions are met
		
	}

	onActionCompleted = function(_act)
	{
		Log.logInfo($"Action completed successfully: {plan[currentActionIndex]}");

	    // Final cleanup for completed action
	    _act.cleanup();
		
	    // Move to the next action or finish the plan
	    currentActionIndex++;
	    if (currentActionIndex >= array_length(plan))
	    {
	        fsm.setState("finished");  // Plan complete
	    }
	    else
	    {
	        var _nextAct = struct_get(actions, plan[currentActionIndex]);
	        _nextAct.doOnEntry();  // Start next action
	        fsm.setState("executing");  // Continue executing
	    }
	}

	isCommittedActionFailed = function(_act)
	{
		var _goapReactionsMet = planner.checkKeysMatch(_act.reactions, captureSensorSnapshot());
		
		return !_act.isInterruptible && !_goapReactionsMet && !_act.isRunning(); // Check if action is committed and failed
		
	}

	onActionFailed = function(_act)
	{
	    
		Log.logWarning($"Failed to execute action: {plan[currentActionIndex]}");

	    // Cleanup for failed committed action
	    _act.cleanup();
    
	    // Replan since the goal wasn't met
	    generatePlan();
	    fsm.setState("start");  // Transition out of executing after failure
	}
	
	#endregion
	
	#endregion
	
	
	#region		<Planner FSM>
	
	fsm = new fsmSYS("GOAP Planner State");
	var _start_state = new state_fsmSYS("start");
	var _executing_state = new state_fsmSYS("executing");
	var _finished_state = new state_fsmSYS("finished");
	
	fsmLog = new Logger("GOAP/Planner/fsm", true, [LogLevel.debug]);
	
	
	_start_state.setOnUpdateCallback(function()
	{
	    // Check if the goal is already satisfied
	    if (planner.checkKeysMatch(targetGoal.conditions, captureSensorSnapshot()))
	    {
	        
			fsmLog.logDebug("Target goal already met. Skipping plan generation.");
	        return; // Skip plan generation if goal is already satisfied
	    }

	    // If the goal is not satisfied, generate a new plan
	    if (array_length(plan) <= 0)
	    {
			fsmLog.logDebug("No plan found — generating...");
			
	        generatePlan();
	        return;
	    }
		
	    // --- Check if the NEXT action in the plan has valid preconditions AT THIS MOMENT ---
	    currentActionIndex = 0; // Make sure we are checking the start of the current plan
	    if (currentActionIndex >= array_length(plan)) // Safety check
	    {
	        fsmLog.logWarning("Plan became empty unexpectedly. Regenerating.");
	        generatePlan(); // Try to get a plan
	        return; // Stay in start state
	    }

	    var _act = struct_get(actions, plan[currentActionIndex]);
	    var currentStateForCheck = captureSensorSnapshot(); // Get current state NOW

	    // Check if the preconditions for THIS action are met in the CURRENT world state
	    if (!planner.checkKeysMatch(_act.conditions, currentStateForCheck)) // <-- This is the check
	    {
	        // Preconditions are false for the next action in the plan BEFORE STARTING IT!
	        Log.logWarning($"Plan's first action ({_act.name}) has invalid preconditions in the current world state. Regenerating.");
	        // Do NOT call doOnEntry or transition to executing
	        generatePlan(); // Generate a NEW plan from the CURRENT state
	        // Stay in the start state to evaluate the NEW plan next frame
	        return;
	    }
	    // --- END Check ---


	    // If we reached here, the next action's preconditions ARE met.
	    // NOW it's safe to start the action.
	    fsmLog.logDebug($"Starting action: {_act.name}");
	    _act.doOnEntry(); // Call entry hook ONLY if conditions are met
	    fsm.setState("executing"); // Transition to executing
		
	});


	_executing_state.setOnUpdateCallback(function()
	{
	    var _act = struct_get(actions, plan[currentActionIndex]);

	    // --- Check for Immediate Interruption ---
	    if (shouldInterruptAction(_act))
	    {
	        handleActionInterruption(_act);
	        return; // Action interrupted, exit update callback
	    }
		

	    // --- If Not Interrupted, Execute Action Step ---
	    _act.execute();

	    // --- Check for Completion After Execution ---
	    if (isActionComplete(_act))
	    {
	        onActionCompleted(_act);
	        return; // Action completed, exit update callback
	    }

	    // --- Handle Committed Actions that Fail Objective ---
	    if (isCommittedActionFailed(_act))
	    {
	        onActionFailed(_act);
	        return; // Action failed, exit update callback
	    }

	    // If none of the above, the action is still running, waiting for completion.
	});


	_finished_state.setOnEnterCallback(function()
	{
		fsmLog.logDebug("GOAP plan complete.");
	
	    // Only generate a new plan if the goal is not satisfied
	    if (!planner.checkKeysMatch(targetGoal.conditions, captureSensorSnapshot()))
	    {
	        generatePlan(); // Only replan if the goal needs it
	    }

	    fsm.setState("start");
	});

	// Setup Planner FSM 
	fsm.addStatesByArray([_start_state, _executing_state, _finished_state]);
	fsm.setState("start");
	
	runPlan = function()
	{
		
		fsmLog.doProfile("fsm.run",fsm.run);
	}
	
	
	
	#endregion
	
}


function plannerGOAP() constructor
{
	planLog = new Logger("GOAP/Planner", true, [LogLevel.info]);
	
    heuristic_cache = {};   // Cache for heuristic values
    //plan_cache = {};        // Cache for previously generated plans
	
    nextID = 1;
	
	astarLog = {
	    nodes_opened: 0,
	    nodes_failed: 0,
	    nodes_processed: 0,
	    actions_evaluated: 0,
		time_took: 0
	}
	
	default_log = variable_clone(astarLog);
	
	resetLog = function()
	{
		astarLog = variable_clone(default_log);
		
		//show_debug_message("Restarting A* Log");
	}
	
	printLog = function()
	{
		show_debug_message("--------------------------");
		show_debug_message($"Log: {astarLog}");
		show_debug_message("----- A* Log of DATA -----");
		
		var _vals = struct_get_names(astarLog);
		
		for(var i=0; i<array_length(_vals); i++)
		{
			var _name = _vals[i];
			var _logVal = struct_get(astarLog, _name);
			
			if string(_name) == "time_took" _logVal = string_format(_logVal, 0, 5);
			
			show_debug_message($"{_name}: {_logVal}");
		}
		show_debug_message("--------------------------");
	}

	
	#region Primary Helper Functions

	
	heuristicScore = function(_state, _goal)
	{
	    var error = 0;

	    var BASE_BOOLEAN_PENALTY = 10;
	    var MISSING_KEY_PENALTY = 50;
	    var INVALID_NUMERIC_PENALTY = 100;

	    var goal_keys = struct_get_names(_goal);
	    for (var i = 0; i < array_length(goal_keys); i++)
	    {
	        var key = goal_keys[i];
	        var condition_data = _goal[$ key];
	        var state_value = struct_exists(_state, key) ? _state[$ key] : undefined;

	        if (is_struct(condition_data) && struct_exists(condition_data, "comparison") && struct_exists(condition_data, "value"))
	        {
	            // --- NUMERICAL CONDITION ---
	            var operator = condition_data.comparison;
	            var target_value = condition_data.value;

	            if (state_value == undefined)
				{
	                error += MISSING_KEY_PENALTY;
	                continue;
	            }

	            if (is_numeric(state_value) && is_numeric(target_value))
	            {
	                var gap = 0;

	                switch (operator)
	                {
	                    case ">=": if (state_value < target_value) gap = target_value - state_value; break;
	                    case "<=": if (state_value > target_value) gap = state_value - target_value; break;
	                    case ">":  if (state_value <= target_value) gap = (target_value - state_value) + 1; break;
	                    case "<":  if (state_value >= target_value) gap = (state_value - target_value) + 1; break;
	                    case "=":  if (state_value != target_value) gap = abs(target_value - state_value); break;
	                    default:   error += INVALID_NUMERIC_PENALTY; break;
	                }

	                error += gap;
	            }
	            else
	            {
	                planLog.logWarning($"heuristicScore: Invalid numeric comparison at key '{key}'. State='{string(state_value)}', Target='{string(target_value)}'");
	                error += INVALID_NUMERIC_PENALTY;
	            }
	        }
	        else
	        {
	            // --- SIMPLE VALUE CONDITION ---
	            var expected_value = condition_data;

	            if (state_value == undefined)
				{
	                error += MISSING_KEY_PENALTY;
	                continue;
	            }

	            if (state_value != expected_value)
	            {
	                // You can expand this to use specific penalties for some keys
	                error += BASE_BOOLEAN_PENALTY;
	            }
	        }
	    }

	    return error;
	}

	checkKeysMatch = function(_conditions_or_reactions, _state_to_check) // Renamed parameters for clarity
	{
	    var _keys = struct_get_names(_conditions_or_reactions); // Iterate keys from the conditions/reactions set
	    for (var i = 0; i < array_length(_keys); i++)
	    {
	        var _key = _keys[i];
	        // Call keyMatches with STATE first, then CONDITIONS/REACTIONS
	        if (!keyMatches(_state_to_check, _conditions_or_reactions, _key)) // <-- Swap parameters here!
	        { 
	            return false; // If ANY key doesn't match, the whole set doesn't match
	        }
	    }
	    return true; // If all keys matched, the whole set matches
	}

    reconstructPath = function(_node)
	{
        var path = [];
        while (_node.parent != undefined)
		{
            array_insert(path, 0, _node);
            _node = _node.parent;
			
        }
        return path;
    }
	
	getActionsForGoal = function(goal_node) // goal_node is the final astarNode
	{
	    var actions = []; // This array will store ACTION NAMES (strings)
		
	    // Start from the goal node and walk back through parents
	    var current = goal_node; // 'current' should be an astarNode

	    // --- DEBUG Start of Path Reconstruction ---
	    if (current == undefined)
		{
	        //show_debug_message("getActionsForGoal: Started with undefined goal_node!"); // Should not happen if a path was found
	        return [];
	    }
	    //show_debug_message($"getActionsForGoal: Starting reconstruction from node ID {current.ID}");
	    // --- END DEBUG ---

	    // While current node is valid and has a parent (i.e., not the start node)
	    while (current != undefined && current.parent != undefined) // <-- Error is reported on this line
		{
		    // --- DEBUG Inside Reconstruction Loop ---
		    //show_debug_message($"  getActionsForGoal: Checking node ID {current.ID}");
		    //show_debug_message($"    Parent property: Type = {typeof(current.parent)}, Value = {string(current.parent)}"); // Log parent's type and value

		    // Add checks for unexpected types just before the line where error happens
		    if (is_string(current.parent))
			{
		        //show_debug_message($"  getActionsForGoal: ERROR DETECTED - Parent is a string! Value: {string(current.parent)}");
		        // This is the state we suspect leads to the error
		        // You might need to break or return here to prevent the crash if it's about to happen
		        //break; // Uncomment to break the loop
		    }
		    if (!is_struct(current.parent) && current.parent != undefined)
			{
		        //show_debug_message($"  getActionsForGoal: ERROR DETECTED - Parent is defined but not a constructor! Type: {typeof(current.parent)}, Value: {string(current.parent)}");
		        // break; // Uncomment to break the loop
		    }
		    // --- END DEBUG ---


	        array_push(actions, current.action); // Collect the action NAME (string)
	        current = current.parent; // Move up to the parent node
	    }

	    // --- DEBUG End of Loop ---
	    //show_debug_message("getActionsForGoal: Finished loop.");
	    //show_debug_message($"Final 'current' after loop: Type = {typeof(current)}, Value = {string(current)}"); // Should be undefined
	    // --- END DEBUG ---

	    // The actions are collected in reverse order, so reverse them for correct sequence
	    actions = array_reverse(actions); // Array of strings

	    return actions; // Returns array of action names
	}

	#endregion
	
	
	#region Secondary Helper Functions
	
	
	keyMatches = function(_state_to_check, _target_struct, _key_to_check)
	{
	    // Check if the key exists in the state we are checking against
	    if (!struct_exists(_state_to_check, _key_to_check))
	    {
	        // If the key isn't in the state, the condition isn't met.
	        // planLog.logDebug($"keyMatches: Key '{_key_to_check}' not found in state."); // Optional debug
	        return false;
	    }

	    var state_value = _state_to_check[$ _key_to_check];
	    var condition_definition = _target_struct[$ _key_to_check]; // Get the condition definition from the target struct (either goal or action conditions)


	    // --- Handle Numerical Conditions (Condition definition is a struct with comparison and value) ---
	    if (is_struct(condition_definition) && struct_exists(condition_definition, "comparison") && struct_exists(condition_definition, "value"))
	    {
	        var operator = condition_definition.comparison;
	        var target_value = condition_definition.value;

	        // Ensure both state value and target value are numeric for numerical comparison
	        if (!is_numeric(state_value) || !is_numeric(target_value))
	        {
	            // If either isn't numeric, the condition can't be numerically matched.
	            planLog.logError($"keyMatches: Numerical comparison for key '{_key_to_check}' requires numeric values. State is '{string(state_value)}', Target is '{string(target_value)}'.");
	            return false;
	        }

	        var result = false; // Initialize the boolean result for the comparison

	        // Perform the numerical comparison based on the operator string
	        switch (operator)
	        {
	            case ">=": result = state_value >= target_value; break;
	            case "<=": result = state_value <= target_value; break;
	            case ">":  result = state_value > target_value; break;
	            case "<":  result = state_value < target_value; break;
	            case "=":  result = state_value == target_value; break;
	            case "!=": result = state_value != target_value; break; // Include != if you support it

	            default:
	                planLog.logError($"keyMatches: Unknown comparison operator '{operator}' for key '{_key_to_check}'.");
	                return false; // An unknown operator means the condition is not met
	        }

	        return result; // Return the actual boolean result of the numerical comparison
	    }
	    // --- Handle Simple Boolean/Value Conditions (Condition definition is a direct value) ---
	    else
	    {
	        var condition_value = condition_definition;

	        // For simple conditions, the state value must exactly match the condition value.
	        // We already checked if the key exists in the state.
	        return state_value == condition_value;
	    }
	}
	
	// --- Simulate applying an action's reactions to a state ---
    simulateReactions = function(_state, _reactions)
    {
        var new_state = variable_clone(_state); // Start with a copy of the current state
        var reaction_keys = struct_get_names(_reactions);

        for (var i = 0; i < array_length(reaction_keys); i++)
        {
            var key = reaction_keys[i];
            var reaction_value = _reactions[$ key];

            // Check if the state variable exists before attempting to modify it
            // If the reaction is to add a new state variable, add it.
            if (!struct_exists(new_state, key))
			{
                 new_state[$ key] = reaction_value;
                 planLog.logDebug($"Simulating Reaction: Added new key '{key}' with value '{string(reaction_value)}'");
                 continue; // Move to the next reaction
            }

            // --- CORRECTED LOGIC FOR APPLYING REACTIONS ---
            // Prioritize setting boolean values if the reaction value is a boolean.
            if (is_bool(reaction_value))
            {
                 new_state[$ key] = reaction_value; // Direct assignment for booleans
                 planLog.logDebug($"Simulating Reaction: Key '{key}' set to boolean '{string(reaction_value)}'.");
            }
            // Handle numerical changes (+N, -N) ONLY if the reaction value is numeric AND the state value is numeric
            else if (is_numeric(reaction_value) && is_numeric(new_state[$ key]))
            {
                new_state[$ key] += reaction_value; // Apply the numerical change (add or subtract)
                planLog.logDebug($"Simulating Reaction: Key '{key}' numerical change by {string(reaction_value)}. New value: {string(new_state[$ key])}");
            }
            // For all other cases (strings, or numbers for non-numeric state properties, or direct number assignments),
            // treat it as a direct SET value.
            else
            {
                 new_state[$ key] = reaction_value; // Direct assignment
                 planLog.logDebug($"Simulating Reaction: Key '{key}' set to '{string(reaction_value)}'.");
            }


        }
        return new_state;
    }

	#endregion
	
	
	#region		<Planning>
	
	
	function astarNode(_id, _state, _action, _g, _h, _parent) constructor
	{
	    ID      = _id;                    // unique numeric
	    state   = variable_clone(_state);    // 
	    action  = _action;                // string name
	    g       = _g;                     // accumulated cost
	    h       = _h;                     // heuristic
	    f       = _g + _h;                // total score
	    parent  = _parent;                // link to another astarNode
	}
	
	
	#region		Helper Functions for createPlan
	
	
	initStartNode = function(start_state, goal_state)
	{
	    var h = heuristicScore(start_state, goal_state);
	    return new astarNode(0, start_state, "", 0, h, undefined);
	}

	calculateHeuristic = function(state, goal)
	{
	    var key = hashState(state);
	    if (struct_exists(heuristic_cache, key))
		{
	        
			var _data = struct_get(heuristic_cache, key);
			
			planLog.logDebug($"Heuristic cache found: {heuristic_cache}");
	        return _data;
	    }
		
	    var h = heuristicScore(state, goal);
	    struct_set(heuristic_cache, key, h);
	    return h;
	}

	hashState = function(_state)
	{
	    var keys = struct_get_names(_state);
	    array_sort(keys, true); // VERY IMPORTANT: Sort keys alphabetically
	    var str = "{";
	    for (var i = 0; i < array_length(keys); i++)
		{
	        var key = keys[i];
	        var value = _state[$ key];
	        str += string(key) + ":" + string(value); // Convert key and value to string consistently
	        if (i < array_length(keys) - 1)
			{
	            str += ",";
	        }
	    }
	    str += "}"; // Add delimiters to the start/end for clarity
	    return str;
	}
	
	expandNode = function(current, goal_state, actions, open_queue, visited_nodes)
	{
	    var keys = array_shuffle(struct_get_names(actions));
	    //show_debug_message($"--- Expanding from State ID {current.ID} (g:{current.g}, h:{current.h}, f:{current.f}, Hash:{hashState(current.state)}) ---"); // Log current state details
	    //show_debug_message($"Considering {array_length(keys)} actions.");

	    for (var i = 0; i < array_length(keys); i++)
	    {
		    var action_name = keys[i];
		    var action = actions[$ action_name];
		    //show_debug_message($"  -> Considering Action: {action_name}");

		    // --- Check Conditions ---
		    var preconditions_met = checkKeysMatch(action.conditions, current.state);
		    //show_debug_message($"    Conditions Met: {preconditions_met}");

		    if (!preconditions_met)
			{
		        astarLog.nodes_failed++;
		        //show_debug_message($"    Conditions NOT met for {action_name}. Skipping action.");
		        continue; // Skip this action, conditions not met
		    }
			// --- End Check Conditions ---

			// --- Simulate Reactions ---
		    //show_debug_message($"    Conditions MET. Simulating reactions for {action_name}...");
		    var new_state = simulateReactions(current.state, action.reactions);
			
			// --- Visited Node Check ---
		    var new_key = hashState(new_state); // <-- Ensure hashState is used here and is correct
		    if (struct_exists(visited_nodes, new_key))
			{
				var visited_node_id = visited_nodes[$ new_key]; // If you stored ID when marking visited
				//show_debug_message($"    State (Hash: {new_key}) for {action_name} already visited (Node ID: {visited_node_id ? visited_node_id : "unknown" }). Skipping.");
				continue; // Skip this state, already visited
			}
			// --- End Visited Node Check ---

			 //--- Calculate Costs and Heuristic ---
		    var g2 = current.g + action.cost;
		    var h2 = calculateHeuristic(new_state, goal_state); // Make sure calculateHeuristic uses hashState
			var f2 = g2 + h2;
		    //show_debug_message($"    Costs for {action_name} -> New State: g={g2}, h={h2}, f={f2}");

			 //--- Create and Add New Node ---
		    var new_node = new astarNode(nextID++, new_state, action.name, g2, h2, current);
		    ds_priority_add(open_queue, new_node, new_node.f);
		    struct_set(visited_nodes, new_key, new_node.ID); // Store the node ID with the hash!
		    astarLog.nodes_opened++;
		    //show_debug_message($"    Added New Node ID {new_node.ID} (Hash: {new_key}) to Open Queue.");

		}
	    //show_debug_message($"--- Finished Expanding State ID {current.ID} ---");
	}
	
	processPlanningLoop = function(open_queue, visited_nodes, goal_state, actions)
	{
	    while (!ds_priority_empty(open_queue))
	    {
	        var current = ds_priority_delete_min(open_queue); // Get the best node

	        // Increment processed node count
	        astarLog.nodes_processed++;

	        // --- DEBUG GOAL CHECK ---
	        //show_debug_message($"--- Checking Goal for State ID {current.ID} (Hash: {hashState(current.state)}) ---");
	        var goal_check_result = checkKeysMatch(goal_state, current.state);
	        //show_debug_message($"Goal Check Result: {goal_check_result}");
	        // --- END DEBUG GOAL CHECK ---

	        // If goal is reached
	        if (goal_check_result)
	        {
	            //show_debug_message($"--- GOAL REACHED! State ID {current.ID} ---"); // Add success log
	            astarLog.time_took = current_time - astarLog.time_took;

	            // --- Path Reconstruction BEFORE Destroying Queue ---
	            var plan_nodes = reconstructPath(current); // Reconstruct path (array of astarNodes)

	            // --- NOW Destroy the Queue ---
	            ds_priority_destroy(open_queue); // Destroy the queue after path is reconstructed

	            // --- Get Action Names from Reconstructed Nodes ---
                // You can iterate the plan_nodes array directly to get names,
                // or continue using getActionsForGoal if you prefer its logic.
                // Let's use getActionsForGoal as it seems to expect walking up from the goal node.
                // getActionsForGoal needs the GOAL NODE as input. The goal node is 'current' here.

                var _str_names = getActionsForGoal(current); // Pass the goal node to getActionsForGoal

	            // Debug log the final action names found
	            show_debug_message($"getActionsForGoal returned plan: {string(_str_names)}");

	            return _str_names; // Return array of action names
	        }

	        // If goal not reached, expand the current node
	        expandNode(current, goal_state, actions, open_queue, visited_nodes);
	    }

	    // If the loop finishes (queue is empty and goal not found)
	    ds_priority_destroy(open_queue); // Destroy the queue here too if loop finishes naturally
	    show_debug_message("Process Planning Loop finished without finding a plan.");
	    return []; // Return an empty plan
	}


	#endregion
	
	
	createPlan = function(_start_state, _goal_state, _actions)
	{
	    resetLog();
	    astarLog.time_took = current_time;

	    var open_queue = ds_priority_create();
	    var visited_nodes = {};

	    var start_node = initStartNode(_start_state, _goal_state);
	    ds_priority_add(open_queue, start_node, start_node.f);
	    struct_set(visited_nodes, hashState(_start_state), true);

	    var _finalPlan = processPlanningLoop(open_queue, visited_nodes, _goal_state, _actions);
		return _finalPlan;	//	return a array with names of the actions as strings
	}

	
	#endregion
	
}


#region Node Stuff


function nodeGOAP(_name) constructor
{
	//uuid = "node_"//+generateUUID(8);
	
	name = _name;
	
	conditions = {};
	
	
	showDebug = false; 
	
	
	addCondition = function(_name, _comp, _val)
	{
		if (struct_exists(conditions, _name))
		{
			if showDebug show_debug_message($"Condition ({_name}) Exists Already.");
			return;
		}
		
		struct_set(conditions, _name, {comparison: _comp , value: _val});
		
	}
	
	addSimpleCondition = function(_name, _val)
	{
		if (struct_exists(conditions, _name))
		{
			if showDebug show_debug_message($"Condition ({_name}) Exists Already.");
			return;
		}
		
		struct_set(conditions, _name, _val);
	}
	
	addEualToCondition = function(_name, _val) { addCondition(_name, "=", _val); }
	addGreaterThanCondition = function(_name, _val) { addCondition(_name, ">", _val); }
	addGreaterThanOrEqualToCondition = function(_name, _val) { addCondition(_name, ">=", _val); }
	addLessThanCondition = function(_name, _val) { addCondition(_name, "<", _val); }
	addLessThanOrEqualToCondition = function(_name, _val) { addCondition(_name, "<=", _val); }
	
	
}

enum actionStatus
{
	idle,
	running,
	success,
	failure,
}

function actionGOAP(_name, _cost) : nodeGOAP(_name) constructor
{
	cost = _cost;
	reactions = {};
	isInterruptible = true;
	
	
	status = actionStatus.idle; //idle, running, success, failure
	
	#region		-- Setup the custom user functoins
	
	// Optional functions 
	executeFunction = undefined;
	onEntryFunc = undefined;
	onExitFunc = undefined;
	
	// Flags to track whether onEntry and onExit have been executed
    onEntryDone = false;
    onExitDone = false;
	started = false;
	
	#endregion
	
	#region		--- Public User Functions
	
	addReaction = function(_name, _val)
	{
		if (struct_exists(reactions, _name))
		{
			if showDebug show_debug_message($"Reaction ({_name}) Exists Already.");
			return;
		}
		
		
		struct_set(reactions, _name, _val);
	}
	
	
	
	// Function to set the execution logic
    setExecuteFunction = function(_func)
	{
        executeFunction = _func;  // Set the function that executes the action
    }
    
	setEntryFunction = function(_func)
	{
		onEntryFunc = _func;
	}
	
	setExitFunction = function(_func)
	{
		onExitFunc = _func;
	}
	
	canBeInterrupted = function(_val)
	{
		isInterruptible = _val;
	}

	#endregion	
	
	#region		-- Doing the custom user functions
	
    // Function to execute the action
    execute = function()
	{
        if (executeFunction != undefined)
		{
            executeFunction();  // Call the function to execute the action
        }
        
    }
	
	// Ensure onEntry is only done once
    doOnEntry = function()
    {
		started = true;
		if showDebug and !onEntryDone show_debug_message($"ENTERING Action: {name}");
        if (onEntryFunc != undefined && !onEntryDone)
        {
            onEntryFunc();  // Call the on entry hook function
            onEntryDone = true;  // Set the flag to true after calling the function
			status = actionStatus.running;
        }
    }
    
    // Ensure onExit is only done once
    doOnExit = function()
    {
		started = false;
		
		if showDebug and !onExitDone show_debug_message($"EXITING Action: {name}");
        if (onExitFunc != undefined && !onExitDone)
        {
            onExitFunc();  // Call the on exit hook function
            onExitDone = true;  // Set the flag to true after calling the function
			
			if (status == actionStatus.running)
	        {
	            status = actionStatus.success; // assume success unless changed manually, ie. failure
	        }
			
			
        }
    }
    
	cleanup = function()
	{
		doOnExit();
		reset();
	}
	
	#endregion
	
	isRunning = function()
	{
		return (status == actionStatus.running);
	}
	
    // Reset the flags when the action is completed or needs to reset
    reset = function()
    {
        onEntryDone = false;
        onExitDone = false;
		started = false;
		status = actionStatus.idle;
    }
	
}


function goalGOAP(_name) : nodeGOAP(_name) constructor
{
	
}


#endregion


/*


// --- Real World State Variables for the AI ---
// These are the actual stats/flags the AI instance holds
real_has_weapon = false;
real_ammo = 0;
real_scrap = 0; // Start with 0 scrap
real_weapon_needs_repair = false; // Weapon is NOT broken if we don't have one


// Create an instance of the GOAP brain
goap_brain = new brainGOAP();

// --- Define and Register Sensors ---
// Sensor for HasWeapon (boolean)
goap_brain.registerSensor("HasWeapon", function()
{
    return real_has_weapon; // Read the actual boolean stat
});

// Sensor for Ammo (numerical)
goap_brain.registerSensor("Ammo", function()
{
    return real_ammo; // Read the actual numerical stat
});

// Sensor for Scrap (numerical)
goap_brain.registerSensor("Scrap", function()
{
    return real_scrap; // Read the actual numerical stat
});

// Sensor for WeaponNeedsRepair (boolean)
goap_brain.registerSensor("WeaponNeedsRepair", function()
{
    return real_weapon_needs_repair; // Read the actual boolean stat
});


// --- Define Goal ---
// Goal: Have a weapon, enough ammo, and the weapon is NOT broken
var goal_armed_and_ready = new goalGOAP("ArmedAndReady");
// Goal conditions using numerical and simple formats
goal_armed_and_ready.addSimpleCondition("HasWeapon", true);
goal_armed_and_ready.addGreaterThanOrEqualToCondition("Ammo", 10);
goal_armed_and_ready.addSimpleCondition("WeaponNeedsRepair", false); // Goal is NOT needing repair

// Add the goal to the brain
goap_brain.addGoal(goal_armed_and_ready);


// Action: Find Weapon (Cost 10)
var action_find_weapon = new actionGOAP("FindWeapon", 10);
action_find_weapon.addSimpleCondition("HasWeapon", false);
// Reactions: Gain weapon, and it needs repair
action_find_weapon.addReaction("HasWeapon", true);
action_find_weapon.addReaction("WeaponNeedsRepair", true);
// onEntry: Change the real world state
action_find_weapon.setEntryFunction(function() // Assuming AI instance accessible via 'self' or passed
{
    show_debug_message("AI is finding a weapon...");
    real_has_weapon = true;
    real_weapon_needs_repair = true;
});


// Action: Collect Scrap (Cost 5)
var action_collect_scrap = new actionGOAP("CollectScrap", 5);
// Conditions: None for simplicity in this example
action_collect_scrap.addLessThanCondition("Scrap", 85);
// Reaction: Gain 15 scrap
action_collect_scrap.addReaction("Scrap", +5);
// onEntry: Change the real world state
action_collect_scrap.setEntryFunction(function() // Assuming AI instance accessible via 'self' or passed
{
    show_debug_message("AI is collecting scrap...");
    real_scrap += 15; // Add scrap to the real AI stat
    show_debug_message("AI collected scrap. Total scrap: " + string(real_scrap));
});


// Action: Craft Ammo (Cost 8)
var action_craft_ammo = new actionGOAP("CraftAmmo", 8);
// Conditions: Need enough scrap, and need a weapon
action_craft_ammo.addGreaterThanOrEqualToCondition("Scrap", 5);
action_craft_ammo.addSimpleCondition("HasWeapon", true);
// Reactions: Spend 5 scrap, gain 10 ammo
action_craft_ammo.addReaction("Scrap", -5);
action_craft_ammo.addReaction("Ammo", +10);
// onEntry: Change the real world state
action_craft_ammo.setEntryFunction(function() // Assuming AI instance accessible via 'self' or passed
{
    show_debug_message("AI is crafting ammo...");
    real_scrap -= 5; // Deduct scrap from real AI stat
    real_ammo += 10; // Add ammo to real AI stat
    show_debug_message("AI crafted ammo. Scrap: " + string(real_scrap) + ", Ammo: " + string(real_ammo));
});


// Action: Repair Weapon (Cost 12)
var action_repair_weapon = new actionGOAP("RepairWeapon", 12);
// Conditions: Weapon needs repair, need enough scrap, need a weapon
action_repair_weapon.addSimpleCondition("WeaponNeedsRepair", true);
action_repair_weapon.addGreaterThanOrEqualToCondition("Scrap", 10);
action_repair_weapon.addSimpleCondition("HasWeapon", true);
// Reactions: Spend 10 scrap, weapon no longer needs repair
action_repair_weapon.addReaction("Scrap", -10);
action_repair_weapon.addReaction("WeaponNeedsRepair", false);
// onEntry: Change the real world state
action_repair_weapon.setEntryFunction(function() // Assuming AI instance accessible via 'self' or passed
{
    show_debug_message("AI is repairing weapon...");
    real_scrap -= 10; // Deduct scrap from real AI stat
    real_weapon_needs_repair = false; // Set weapon as repaired
    show_debug_message("AI repaired weapon. Scrap: " + string(real_scrap) + ", Needs Repair: " + string(real_weapon_needs_repair));
});


// Add actions to the brain
goap_brain.addActionsByArray([
    action_find_weapon,
    action_collect_scrap,
    action_craft_ammo,
    action_repair_weapon
]);


// --- Set the Target Goal ---
goap_brain.setTargetGoal("ArmedAndReady");

show_debug_message("Starting GOAP brain with 'Get Armed' goal...");
goap_brain.generatePlan();
// In your Step event, you would then call goap_brain.runPlan();

*/
