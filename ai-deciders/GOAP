
// When creating goap actions think:
/*

	GOAP gets you to the party.
	The party handles itself.
	
	GOAP is about getting into the right context.

	The agent doesn’t plan every bite of food with GOAP —
	It just planned to get to the fridge.
	
*/

// Started : 4:00 PM on April 25, 2025.
// Ended 9:00 PM on April 25, 2025


// Simple T/F GOAP Sys.


function brainGOAP() constructor
{
	randomize();
	
	actions = {};
	goals = {};
	sensors = {};
	
	targetGoal = undefined;
	
	planner = new plannerGOAP(); 
	plan = [];
	currentActionIndex = 0;  // init action index
	
	
	showDebug = true;
	showExtraDebug = false;
	
	#region Primary Functions
	
	addAction = function(_action)
	{
		
		var _name = _action.name;
		
		if struct_exists(actions, _name)
		{
			if showDebug show_debug_message($"Action ({_name}) Exists Already.");
			return;
		}
		
		struct_set(actions, _name, _action);
		
	}
	
	addActionsByArray = function(_actions)
	{
		for(var i=0; i<array_length(_actions); i++)
		{
			var _a = _actions[i];
			addAction(_a);
		}
	}
	
	addGoal = function(_goal)
	{
		
		var _name = _goal.name;
		
		if struct_exists(goals, _name)
		{
			if showDebug show_debug_message($"Goal ({_name}) Exists Already.");
			return;
		}
		
		struct_set(goals, _name, _goal);
		
	}
	
	addGoalsByArray = function(_goals)
	{
		for(var i=0; i<array_length(_goals); i++)
		{
			var _g = _goals[i];
			addGoal(_g);
		}
	}
	
	
	registerSensor = function(_name, _func)
	{
		
		if struct_exists(sensors, _name)
		{
			if showDebug show_debug_message($"Sensor ({_name}) Exists Already.");
			return;
		}
		
		struct_set(sensors, _name, _func);
		
	}
	
	setTargetGoal = function(_goalName)
	{
		
		//show_debug_message("Goals: "+string(goals));
		
		if !struct_exists(goals, _goalName)
		{
			if showDebug show_debug_message("Set target goal failed. Goal DNE.");
			return;
		}
		
		targetGoal = struct_get(goals, _goalName);
		
	}
	
	generatePlan = function()
	{
	    if (showExtraDebug) planner.printLog();
	    

	    if (targetGoal == undefined)
	    {
	        if showDebug show_debug_message("No target goal set. Cannot generate plan.");
        
	        if (array_length(plan) > 0)
	        {
	            plan = [];
	            currentActionIndex = 0;
	            if showDebug show_debug_message("Cleared existing plan due to no target goal.");
	        }

	        return false;
	    }

	    var current_state = captureSnapshot();
	    var goal_state = targetGoal.conditions;
	    var available_actions = actions;
	    var old_plan = plan;

	    var potential_plan_nodes = planner.plan(current_state, goal_state, available_actions);
	    var new_plan = planner.getActionsForGoal(array_last(potential_plan_nodes));

	    // No plan generated
	    if (array_length(new_plan) == 0)
	    {
	        if (array_length(old_plan) > 0)
	        {
	            plan = [];
	            currentActionIndex = 0;
	            if showDebug show_debug_message("No valid plan could be generated. Clearing current plan.");
	        }
	        else if (showDebug && showExtraDebug)
	        {
	            show_debug_message("Still no valid plan could be generated.");
	        }

	        return false;
	    }

	    // Same plan as before
	    if (plansAreEqual(old_plan, new_plan))
	    {
	        if (showDebug && showExtraDebug) show_debug_message("Generated same plan, continuing current execution.");
	        return false;
	    }

	    // New plan generated
	    plan = new_plan;
	    currentActionIndex = 0;
	    if showDebug show_debug_message("New plan generated successfully.");
	    if (showDebug) printPlan();
		
		planner.printLog();
		
	    return true;
	}

	
	// GOAP Execution
	executePlan = function()
	{
	    if is_undefined(targetGoal)
	    {
	        if (showDebug) show_debug_message("Cannot Execute Plan because no goal is set.");
	        return;
	    }
    
	    if array_length(plan) <= 0
	    {
	        generatePlan();
	        return;
	    }
    
	    if (currentActionIndex >= array_length(plan))
	    {
	        if (showDebug) show_debug_message("Completed Plan");
	        generatePlan();
	        return;
	    }

	    var _actionName = plan[currentActionIndex];
	    var _action = struct_get(actions, _actionName);
		
		
		
	    // === 1. FIRST, check if we can still do this action ===
	    if (!planner.preconditionsMet(_action.conditions, captureSnapshot()))
	    {
	        if (showDebug) show_debug_message("Regenerating Plan: Cannot continue " + _actionName + ", due to unmet conditions.");
	        generatePlan();
	        return;
	    }
		
		

	    // === 2. THEN, run the action ===
		_action.doOnEntry();
		_action.execute();
		
		
		// === 3. FINALLY, check if it's complete (effects are satisfied) ===
		if (planner.reactionsSatisfied(_action.reactions, captureSnapshot()))
		{
		    if (showDebug) show_debug_message(_actionName + " is complete.");
		    
			_action.doOnExit();
			_action.reset();  // Reset the entry/exit flags for the next time
			
			currentActionIndex++;
			
			//show_debug_message($"NEW Current Action: {plan[currentActionIndex]}");
		}
		
	}


	
	#endregion

	#region Helper Functions
	
	getSensorValue = function(_sensorName)
	{
		if !struct_exists(sensors, _sensorName)
		{
			if showDebug show_debug_message($"Cannot get Sensor Value for {_sensorName}");
			return undefined;
		}
		
		var _val = struct_get(sensors, _sensorName);
		return _val();
	}
	
	plansAreEqual = function(plan1, plan2)
    {
        // If either plan is undefined, they are not equal unless both are (handled by length check)
        if (is_undefined(plan1) || is_undefined(plan2)) return false;

        if (array_length(plan1) != array_length(plan2))
        {
            return false; // Plans are not equal if lengths differ
        }

        for (var i = 0; i < array_length(plan1); i++)
        {
            if (plan1[i] != plan2[i])
            {
                return false; // Plans are not equal if any action name differs at the same index
            }
        }

        return true; // Plans are equal if lengths and all action names match
    }
	
	getActionFunction = function(_actionName)
	{
		if !struct_exists(actions, _actionName)
		{
			if showDebug show_debug_message($"Cannot get Action Function for {_actionName}");
			return undefined;
		}
		
		var _action = struct_get(actions, _actionName);
		return _action.executeFunction;
		
	}
	
	captureSnapshot = function()
	{
		var _snap = {};
		
		var _sensor_names = struct_get_names(sensors);
		
		for(var i=0; i<array_length(_sensor_names); i++)
		{
			var _name = _sensor_names[i];
			
			var _val = struct_get(sensors, _name);
			
			var _funct_ran = _val();
			
			struct_set(_snap, _name, _funct_ran);
		}
		
		
		return _snap;
		
	}

	printPlan = function()
	{
		var _len = array_length(plan);
		
		if (_len <= 0)
		{
			show_debug_message("Print Plan - Plan is empty.");
			return;
		}
		
		show_debug_message($"({_len}) ~ Printing Plan:");
		
		//show_debug_message(string(plan));
		
		for(var a=0; a<_len; a++)
		{
			
			var _act = plan[a];
			show_debug_message($"{a+1}: {_act}");
			
		}
		
	}
	
	drawSensors = function(_x, _y)
	{
		var _sensor_names = struct_get_names(sensors);
		
		for(var i=0; i<array_length(_sensor_names); i++)
		{
			var _sensor = _sensor_names[i];
			var _val = struct_get(sensors, _sensor);
			
			draw_text(_x, (_y-(20*i)), $"Sensor: {_sensor} ~ {_val()}");
			
		}
		
	}
	
	#endregion
	
}


function plannerGOAP() constructor
{
    open_list = [];
    closed_list = [];
    nextID = 1;
	
	astarLog = {
	    nodes_opened: 0,
	    nodes_failed: 0,
	    nodes_processed: 0,
	    actions_evaluated: 0,
		time_took: 0
	}
	
	default_log = variable_clone(astarLog);
	
	resetLog = function()
	{
		astarLog = variable_clone(default_log);
		
		//show_debug_message("Restarting A* Log");
	}
	
	printLog = function()
	{
		show_debug_message($"Log: {astarLog}");
	}

	
	#region Primary Helper Functions

    heuristicScore = function(_state, _goal)
	{
        var error = 0;
        var keys = struct_get_names(_goal);
        for (var i = 0; i < array_length(keys); i++)
		{
            var key = keys[i];
            if (!hasMatchingKey(_state, _goal, key)) error++;

        }
        return error;
    }

    preconditionsMet = function(_conds, _state)
	{
        var _keys = struct_get_names(_conds);
        for (var i = 0; i < array_length(_keys); i++)
		{
            var key = _keys[i];
			if (!hasMatchingKey(_state, _conds, key)) return false

        }
        return true;
    }

	reactionsSatisfied = function(_effects, _state)
	{
	    var _keys = struct_get_names(_effects);
	    for (var i = 0; i < array_length(_keys); i++)
	    {
	        var key = _keys[i];
	        if (!struct_exists(_state, key) || _state[$ key] != _effects[$ key])
	        {
	            return false;
	        }
	    }
	    return true;
	}


    statesEqual = function(_a, _b)
	{
        var keys = struct_get_names(_b);
        for (var i = 0; i < array_length(keys); i++)
		{
            var key = keys[i];
            if (!struct_exists(_a, key) || _a[$ key] != _b[$ key])
			{
                return false;
            }
        }
        return true;
    }

    listContainsState = function(_list, _state)
	{
		//if _state == undefined return false;
		
        for (var i = 0; i < array_length(_list); i++)
		{
            if (statesEqual(_list[i].state, _state)) return true;
        }
        return false;
    }

    indexOfState = function(_list, _state)
	{
        for (var i = 0; i < array_length(_list); i++)
		{
            if (statesEqual(_list[i].state, _state)) return i;
        }
        return -1;
    }

    reconstructPath = function(_node)
	{
        var path = [];
        while (_node.parent != undefined)
		{
            array_insert(path, 0, _node);
            _node = _node.parent;
        }
        return path;
    }
	
	getActionsForGoal = function(goal_node)
	{
	    var actions = [];

	    // Start from the goal node and walk back through parents
	    var current = goal_node;
	    while (current != undefined && current.parent != undefined)
		{
	        array_push(actions, current.action); // Collect the action at this node
	        current = current.parent; // Move to the parent node
	    }

	    // The actions are collected in reverse order, so reverse them for correct sequence
	    actions = array_reverse(actions);

	    return actions;
	}

	#endregion
	
	#region Secondary Helper Functions
	
	
	hasMatchingKey = function(_a, _b, key)
	{
	    return struct_exists(_a, key) && _a[$ key] == _b[$ key];
	}

	
	
	getBestNode = function(_list)
	{
	    var best_f = infinity; // very big number
	    var candidates = [];

	    for (var i = 0; i < array_length(_list); i++)
	    {
	        var node = _list[i];
	        if (node.f < best_f)
	        {
	            best_f = node.f;
	            candidates = [node]; // new best node found
	        }
	        else if (node.f == best_f)
	        {
	            array_push(candidates, node); // another equally good node
	        }
	    }

	    // Now pick randomly among the best candidates
	    return candidates[irandom(array_length(candidates) - 1)];
	}
	
	moveNode = function(node, from_list, to_list)
	{
	    // Manually find the node by ID (or use state match if you prefer)
	    for (var i = 0; i < array_length(from_list); i++)
		{
	        if (from_list[i].ID == node.ID)
			{
	            array_delete(from_list, i, 1);
	            break;
	        }
	    }
	    array_push(to_list, node);
		
	}

	applyStateEffects = function(state, effects)
	{
	    var new_state = variable_clone(state);
	    var keys = struct_get_names(effects);
	    for (var i = 0; i < array_length(keys); i++)
		{
	        var k = keys[i];
	        new_state[$ k] = effects[$ k];
	    }
	    return new_state;
	}

	updateNode = function(node, g, h, f, parent, action_name)
	{
	    node.g = g;
	    node.h = h;
	    node.f = f;
	    node.parent = parent;
	    node.action = action_name;
	}

	#endregion
	
	#region		<Planning>
	
	
	function astarNode(_id, _state, _action, _g, _h, _parent) constructor
	{
	    ID      = _id;                    // unique numeric
	    state   = variable_clone(_state);    // 
	    action  = _action;                // string name
	    g       = _g;                     // accumulated cost
	    h       = _h;                     // heuristic
	    f       = _g + _h;                // total score
	    parent  = _parent;                // link to another astarNode
	}


    plan = function(_start_state, _goal_state, _actions)
	{
		
		resetLog();
		astarLog.time_took = current_time;
		
	    // 1. Init
	    open_list = [];
	    closed_list = [];
	    nextID = 1;

	    var start_node = new astarNode(0, _start_state, "", 0, heuristicScore(_start_state, _goal_state), undefined);
	    array_push(open_list, start_node);

	    // 2. Main Loop
	    while (array_length(open_list) > 0)
	    {
	        var current = getBestNode(open_list);
	        moveNode(current, open_list, closed_list);
			
			astarLog.nodes_processed++;

	        if (statesEqual(current.state, _goal_state))
			{
				
				astarLog.time_took = (current_time - astarLog.time_took);
				
				
				
	            return reconstructPath(current);
	        }

	        // 3. Check available actions
	        var action_keys = struct_get_names(_actions);
			
			action_keys = array_shuffle(action_keys);	// Evaluate Nodes Equally even if their the same cost or action conditions and reactions 
			
	        for (var i = 0; i < array_length(action_keys); i++)
	        {
	            var action = _actions[$ action_keys[i]];
				
				
	            if (!preconditionsMet(action.conditions, current.state))
				{
					// Increment the counter for failed nodes (actions that don't meet conditions)
					astarLog.nodes_failed++;
					continue;
				}
				
	            // 4. Apply effects to get new state
	            var new_state = applyStateEffects(current.state, action.reactions);

	            // 5. Skip if already seen
	            if (listContainsState(closed_list, new_state)) continue;

	            var g2 = current.g + action.cost;
	            var h2 = heuristicScore(new_state, _goal_state);
	            var f2 = g2 + h2;

	            var existing_index = indexOfState(open_list, new_state);
	            if (existing_index != -1)
	            {
	                var existing = open_list[existing_index];
	                if (g2 < existing.g)
	                {
	                    updateNode(existing, g2, h2, f2, current, action.name);
	                }
	                continue;
	            }

	            // 6. New node
	            var new_node = new astarNode(nextID++, new_state, action.name, g2, h2, current);
	            array_push(open_list, new_node);
				
				
				
				// Increment the counter for nodes opened
				astarLog.nodes_opened++;
	        }
			
	    }
		
		
		
		
	    // No plan found
	    return [];
	}


	#endregion
	
}


#region Node Stuff

function nodeGOAP(_name) constructor
{
	name = _name;
	
	conditions = {};
	reactions = {};
	
	showDebug = true; 
	
	addCondition = function(_name, _val)
	{
		if (struct_exists(conditions, _name))
		{
			if showDebug show_debug_message($"Condition ({_name}) Exists Already.");
			return;
		}
		
		struct_set(conditions, _name, _val);
		
	}
	
	addReaction = function(_name, _val)
	{
		if (struct_exists(reactions, _name))
		{
			if showDebug show_debug_message($"Reaction ({_name}) Exists Already.");
			return;
		}
		
		//if !(struct_exists(conditions, _name))
		//{
		//	if showDebug show_debug_message($"Trying to add reaction ({_name}) without matching condition.");
		//	return;
		//}
		
		struct_set(reactions, _name, _val);
	}
	
	
}


function actionGOAP(_name, _cost) : nodeGOAP(_name) constructor
{
	cost = _cost;
	
	// needed if you're using the executePlan function
	executeFunction = undefined;
	
	// Optional functions 
	onEntryFunc = undefined;
	onExitFunc = undefined;
	
	// Flags to track whether onEntry and onExit have been executed
    onEntryDone = false;
    onExitDone = false;
	
	// Function to set the execution logic
    setExecuteFunction = function(_func)
	{
        executeFunction = _func;  // Set the function that executes the action
    }
    
	setEntryFunction = function(_func)
	{
		onEntryFunc = _func;
	}
	
	setExitFunction = function(_func)
	{
		onExitFunc = _func;
	}
	
    // Function to execute the action
    execute = function()
	{
        if (executeFunction != undefined)
		{
            executeFunction();  // Call the function to execute the action
        }
        
    }
	
	// Ensure onEntry is only done once
    doOnEntry = function()
    {
		
		if showDebug and !onEntryDone show_debug_message($"ENTERING Action: {name}");
        if (onEntryFunc != undefined && !onEntryDone)
        {
            onEntryFunc();  // Call the on entry hook function
            onEntryDone = true;  // Set the flag to true after calling the function
        }
    }
    
    // Ensure onExit is only done once
    doOnExit = function()
    {
		if showDebug and !onExitDone show_debug_message($"EXITING Action: {name}");
        if (onExitFunc != undefined && !onExitDone)
        {
            onExitFunc();  // Call the on exit hook function
            onExitDone = true;  // Set the flag to true after calling the function
			// the flag is lwk redundant but leave it 
        }
    }
    
    // Reset the flags when the action is completed or needs to reset
    reset = function()
    {
        onEntryDone = false;
        onExitDone = false;
    }
	
}


function goalGOAP(_name) : nodeGOAP(_name) constructor
{
	// you can add priorities, a lot of different things
	
	
}

#endregion


// Integer Based T/F GOAP Sys.



/*

Example Code:

// GOAP BRAIN
brain = new brainGOAP();

//Actions
var makeActionBuildFire = new actionGOAP("BuildFire", 2); 
makeActionBuildFire.addCondition("hasWood", true);
makeActionBuildFire.addReaction("hasFire", true);
makeActionBuildFire.setExecuteFunction(function()
{
	show_debug_message("build fye.");
	return true;
});

var makeActionGatherWood = new actionGOAP("GatherWood", 1); 
makeActionGatherWood.addCondition("hasAxe", true);
makeActionGatherWood.addReaction("hasWood", true);
makeActionGatherWood.setExecuteFunction(function()
{
	show_debug_message("Gather wood.");
	return true;
});

var makeActionWarmUp = new actionGOAP("WarmUp", 1); 
makeActionWarmUp.addCondition("hasFire", true);
makeActionWarmUp.addReaction("StayWarm", true);
makeActionWarmUp.setExecuteFunction(function()
{
	show_debug_message("Warm up by the fye.");
	// return false if the action is not completed. add conditionals or sum.
	return true;
});

// Goals
var makeGoalStayWarm = new goalGOAP("StayWarm");
makeGoalStayWarm.addCondition("StayWarm", true);


// Register sensors (these return the world state)
brain.registerSensor("hasAxe", function() { return true; });
brain.registerSensor("hasWood", function() { return false; });
brain.registerSensor("hasFire", function() { return false; });

//for the sensors you need to make them return true or false

//example:
//function hasWood()
//{
//	if inventoryHas("wood")
//	{
//		return true;
//	} else {
//		return false;
//	}
//}



// Add actions
brain.addAction(makeActionGatherWood);
brain.addAction(makeActionBuildFire);
brain.addAction(makeActionWarmUp);

// Add goal
brain.addGoal(makeGoalStayWarm);

// Set target goal
brain.setTargetGoal("StayWarm");

// Create plan
brain.generatePlan();

brain.printPlan();


// Place in Step Event 
brain.executePlan();


*/

